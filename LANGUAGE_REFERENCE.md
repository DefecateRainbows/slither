# slither Language Reference

## Lexical Analysis

A slither program is read by a parser. Input to the parse is a stream of
tokens, generated by the lexical analyser.

Slither reads a program as Unicode code points.

A slither program is divided into a number of logical statements. A logical
statement may span any length of source text.

### Comments

A single-line comment starts with `//`. Until the lexer reaches a newline
(`\n`, `\r\n`) it will discard all characters.

A multi-line comment starts with `/*` and ends with `*/`. Until the lexer
reaches `*/` it will discard all characters.

### Whitespace between tokens

The whitespace characters space, tab and formfeed can be used interchangeably
to separate tokens. Whitespace is needed between two tokens only if their
concatenation could otherwise be interpreted as a different token (e.g., ab
is one token, but a b is two tokens).

### Tokens

The following categories of tokens exist: identifiers, keywords, literals,
operators, and delimiters. Whitespace characters are not tokens, but serve to
delimit tokens.

#### Identifiers and Keywords

Identifiers are described by the following lexical definitions.

```
identifier  ::= id_start id_continue*
id_start    ::= A-Z a-z _
id_continue ::= A-Z a-z _ 0-9
```

The following identifiers are used as reserved words, or keywords of the
language, and cannot be used as ordinary identifiers. They must be spelled
exactly as written here:

```
true       throw       else       from
false      return      while      async
null       try         for        await
this       catch       in         gen
class      finally     new        yield
function   break       import     typeof
let        continue    export     void
const      if          default
```

#### Literals

Literals are notations for constant values of some built-in types.

null
true
false
string
template
number
symbol
regex

#### Operators

The following tokens are operators:

```
+       -       *       **      /       %
<<      >>      &       |       ^       ~
<       >       <=      >=      ==      !=     ?
```

The following tokens serve as delimiters in the grammar:

```
(       )       [       ]       {       }
,       :       .       ;       =       =>
+=      -=      *=      /=      //=     %=
&=      |=      ^=      >>=     <<=     **=
$(
```

The following ASCII characters have special meaning as part of tokens or are
otherwise significant to the lexer:

```
'       "       \       `
```

## Data model

### Objects

Objects are slither's abstraction for data. All data in a slither program is
represented by objects or by relations between objects.

Every object has an identity, a type and a value. An object’s identity never
changes once it has been created.

An object’s type determines the operations that the object supports (e.g.,
"does it have a length?") and also defines the possible values for objects of
that type. Like its identity, an object’s type is also unchangeable.

The value of some objects can change. Objects whose value can change are said
to be mutable; objects whose value is unchangeable once they are created are
called immutable. (The value of an immutable container object that contains a
reference to a mutable object can change when the latter’s value is changed;
however the container is still considered immutable, because the collection of
objects it contains cannot be changed. So, immutability is not strictly the
same as having an unchangeable value, it is more subtle.) An object’s
mutability is determined by its type; for instance, numbers, strings and
symbols are immutable, while arrays are mutable.

Objects are never explicitly destroyed; however, when they become unreachable
they may be garbage-collected.

## Execution model

A slither program is constructed from code blocks. A block is a piece of
slither program text is executed as a unit. A module and a function body are
examples of blocks.

A code block is executed in an execution context. An execution context contains
information about the data used in a code block and instructions on how
execution continues after a code block's execution has completed.

### Bindings

Bindings refer to objects. The following constructs create bindings: formal
parameters to functions, import statements, function definitions, for loop
headers, catch blocks, and lexical declarations. Declarative bindings may be
marked as exports for use in other modules.

A binding is scoped to a lexical environment. A lexical environment is formed
by a block.

#### Resolution of bindings

A scope defines the visibility of a name within a block. If a variable is
declared within a block, its scope includes that block.

When an identifier is used in a code block, it is resolved using the nearest
enclosing scope. The set of all such scopes visible to a code block is called
the block's environment.

If a declaration occurs anywhere within a block, all uses of the binding within
the block are treated as references to that binding. This can lead to errors
when a binding is used before it is declared.

### Exceptions

Exceptions are a means of breaking out of the normal flow of control of a code
block in order to handle errors or other exceptional conditions. An exception
is raised at the point where the error is detected; it may be handled by the
surrounding code block or by any code block that directly or indirectly invoked
the code block where the error occurred.

slither uses the "termination" model of error handling: an exception handler
can find out what happened and continue execution at an outer level, but it
cannot repair the cause of the error and retry the failing operation (except by
re-entering the offending piece of code from the top).

When an exception is not handled at all, slither terminates execution of the
program.

## The module system

slither code in one module gains access to the code in another module by the
process of importing it.

The import statement combines two operations; it searches for the named module,
then it binds the results of that search to a name in the local scope.

## Expressions

### Binary expressions

The binary arithmetic operations have the conventional priority levels. Note
that some of these operations also apply to certain non-numeric types.
```
power       ::= unary ["**" mul]
mul         ::= power "*" add
add         ::= mul ("+" "-") shift
shift       ::= add ("<<" ">>") relational
relational  ::= shift (">" "<" "<=" ">=") equality
equality    ::= relational ("==" "!=") bitwise_and
bitwise_and ::= equality "&" bitwise_xor
bitwise_xor ::= bitwise_and "^" bitwise_or
bitwise_or  ::= bitwise_xor "|" logical_and
logical_and ::= bitwise_or "&&" logical_or
logical_or  ::= logical_and "||" conditional
```

The `/` (division) operator yields the quotient of its arguments.

The `%` (modulo) operator yields the remainder from the division of the first
argument by the second.

The `+` (addition) operator yields the sum of its arguments. The arguments must
either both be numbers or both be strings. In the former case, the numbers are
added together. In the latter case, the strings are concatenated.

The `-` (subtraction) operator yields the difference of its arguments

### Unary expressions

```
unary ::= ("typeof" "void" "!" "+" "-" "await") unary
```

#### Await expressions

### Conditional expressions

```
conditional ::= logical_or "?" assignment ":" assignment
```

Conditional expressions (sometimes called a "ternary operator") have the lowest
priority of all slither operations.

The expression `C ? x : y` first evaluates the condition, C. If C is true, x is
evaluated and its value is returned; otherwise, y is evaluated and its value is
returned.

### Assignment expressions

```
assignment ::= conditional ("=" "+=" "-=" "*=" "/=" "**=" "%=") assignment
assignment ::= "yield" assignment
```

#### Yield expressions

```
yield ::= "yield" (assignment)
```

The yield expression is used in the body of a generator function. When a
generator is called, it returns an iterator. The execution starts when one of
the iterator's methods is called. At that time, the execution proceeds to the
first yield expression, where it is suspended again, returning the value of
`assignment` to the generator’s caller. By suspended, it is meant that all
local state is retained, including the current bindings of local variables, the
instruction pointer, the internal evaluation stack, and the state of any
exception handling. When the execution is resumed by calling one of the
generator’s methods, the function can proceed exactly as if the yield
expression were just another external call. The value of the yield expression
after resuming depends on the method which resumed the execution.

### Primary expressions

#### Literals

##### Null

##### True

##### False

##### Numbers

##### Strings

##### Templates

##### Symbols

##### Regex

##### Objects

##### Arrays

#### Function expressions

#### Arrow function expressions

#### Parenthesized form

## Statements

### Expression statements

### Block statements

### If statements

### Return statements

### Throw statements

### While loop statements

### For loop statements

### Break statements

### Continue statements
